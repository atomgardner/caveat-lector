#include <inttypes.h>

#include "blob.h"

//
// Mersenne twister (Matsumoto & Nishimura)
//  len_word = 32	 // w 
//  len_recurrence = 624 // n
//  len_split = 397	 // m
//  len_mix = 31	 // r
//
//
//  tempering
//    u, d = 11, FFFFFFFF
//    s, b =  7, 9D2C5680
//    t, c = 15, EFC60000
//    l = 18
//
// Refs:
//  https://en.wikipedia.org/wiki/Mersenne_Twister
//

#define len_word       32;
#define len_recurrence 624
#define pos_fold       397
#define len_mix         31
#define A_n            0x9908b0df

struct state {
	size_t head;
	uint32_t x[624];
};

typedef struct state mersenne_twister;

static void mt_init(struct state *mt, uint32_t seed)
{
	mt->x[0] = seed;
	
	for (size_t k = 1; k < len_recurrence; k++)
		mt->x[k] = (uint32_t)1812433253
			* (mt->x[k - 1] ^ (mt->x[k - 1] >> 30))
			+ (uint32_t)k;

	mt->head = len_recurrence;
	return;
}

inline void mt_twist(struct state *mt)
{
	// probably would be faster with preprocessor magic
	uint32_t upper = (uint32_t)1 << len_mix;
	uint32_t lower = upper ^ ~(uint32_t)0;

	for (size_t k = 0; k < len_recurrence; k++) {
		//
		// New states are generated by
		//
		// 	x_{n + k} := x_{m + k} +_2 (x^u_k |x^l_{k+1}) A
		//
		// where ^u and ^l denote masks of the upper `w-r` and lower `r`
		// bytes.
		//
		// The matrix `A` is a super diagonal of `1`s, with a bit
		// vector `a` along the bottom row. This makes the matrix
		// multiplication equivalent to a right shift follwed by a
		// conditional xor with `a`.
		//

		uint32_t y = (mt->x[k] & upper) |
				(mt->x[(k + 1) % len_recurrence] & lower);

		mt->x[k] = mt->x[(k + pos_fold) % len_recurrence] ^ (y >> 1)
			^ (y & 0x01 ? A_n : 0);
	}
}

static uint32_t mt_emit(struct state *state)
{
	uint32_t x;

	if (state->head == len_recurrence) {
		mt_twist(state);
		state->head = 0;
	}

	x = state->x[state->head];
	state->head++;

	x ^= (x >> 11);					// x >> u
	x ^= ((x << 7) & (uint32_t)0x9d2c5680);		// ((y << s) AND b)
	x ^= ((x << 15) & (uint32_t)0xefc60000);	// ((y << t) AND c)
	x ^= (x >> 18);					// y >> l

	return x;
}


static inline int mt_stream_cipher(mersenne_twister *mt, struct blob *msg)
{
	size_t idx_unmasked = 0;
	uint32_t z;

	for (;;) {
		z = mt_emit(mt);

		for (size_t k = 0; k < 4; k++) {
			if (idx_unmasked == msg->len)
				goto done;

			idx_unmasked++;
			uint8_t mask = ((z & ((uint32_t)0xff << 8*k)) >> 8*k); // wtf
			msg->buf[idx_unmasked] ^= mask;
		}
	}

done:
	return 1;
}
